<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>promise | kittyui</title>
    <meta name="description" content="一个vue3组件库">
    <link rel="stylesheet" href="/assets/style.a1db3bef.css">
    <link rel="modulepreload" href="/assets/app.f97f91c0.js">
    <link rel="modulepreload" href="/assets/articles_javascript_promise解读.md.64285721.lean.js">
    
    <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-66204374><!--[--><!--]--><!--[--><span tabindex="-1" data-v-40d8faed></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-40d8faed> Skip to content </a><!--]--><!----><header class="VPNav" data-v-66204374 data-v-574cb7e9><div class="VPNavBar has-sidebar" data-v-574cb7e9 data-v-23964494><div class="container" data-v-23964494><div class="VPNavBarTitle has-sidebar" data-v-23964494 data-v-6d41cef0><a class="title" href="/" data-v-6d41cef0><!--[--><img class="VPImage logo" src="/logo.png" data-v-427376cb><!--]--><!--[-->Kitty<!--]--></a></div><div class="content" data-v-23964494><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-23964494 data-v-36eceb0c><span id="main-nav-aria-label" class="visually-hidden" data-v-36eceb0c>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/articles/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" data-v-36eceb0c data-v-bf51d0ee data-v-0c96c854><!--[-->博客<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/guide/test.html" data-v-36eceb0c data-v-bf51d0ee data-v-0c96c854><!--[-->GuideTest<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="https://github.com/FairyTailYouth" target="_blank" rel="noopener noreferrer" data-v-36eceb0c data-v-bf51d0ee data-v-0c96c854><!--[-->gitee<!--]--><!----></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-36eceb0c data-v-3a84883f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-3a84883f><span class="text" data-v-3a84883f><!----> Drop Menu <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-3a84883f><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-3a84883f><div class="VPMenu" data-v-3a84883f data-v-010f1d8c><div class="items" data-v-010f1d8c><!--[--><!--[--><div class="VPMenuGroup" data-v-010f1d8c data-v-b6b3c7ac><!----><!--[--><!--[--><div class="VPMenuLink" data-v-b6b3c7ac data-v-05edcde0><a class="VPLink link" href="/item-A1.html" data-v-05edcde0 data-v-0c96c854><!--[-->Item A1<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b6b3c7ac data-v-05edcde0><a class="VPLink link" href="/item-A2.html" data-v-05edcde0 data-v-0c96c854><!--[-->Item A2<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-010f1d8c data-v-b6b3c7ac><!----><!--[--><!--[--><div class="VPMenuLink" data-v-b6b3c7ac data-v-05edcde0><a class="VPLink link" href="/item-B1.html" data-v-05edcde0 data-v-0c96c854><!--[-->Item B1<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b6b3c7ac data-v-05edcde0><a class="VPLink link" href="/item-B2.html" data-v-05edcde0 data-v-0c96c854><!--[-->Item B2<!--]--><!----></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-23964494 data-v-513bb74a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-513bb74a data-v-57172cb8 data-v-eeb71742><span class="check" data-v-eeb71742><span class="icon" data-v-eeb71742><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-57172cb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-57172cb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-23964494 data-v-48b47c0c data-v-06a41780><!--[--><a class="VPSocialLink" href="https://github.com/FairyTailYouth" title="github" target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-398c9053><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-398c9053>github</span></a><a class="VPSocialLink" href="..." title="twitter" target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-398c9053><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"></path></svg><span class="visually-hidden" data-v-398c9053>twitter</span></a><a class="VPSocialLink" href="..." target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><!----><span class="visually-hidden" data-v-398c9053>{
  &quot;svg&quot;: &quot;&lt;svg role=\&quot;img\&quot; viewBox=\&quot;0 0 24 24\&quot; xmlns=\&quot;http://www.w3.org/2000/svg\&quot;&gt;&lt;title&gt;Dribbble&lt;/title&gt;&lt;path d=\&quot;M12...6.38z\&quot;/&gt;&lt;/svg&gt;&quot;
}</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-23964494 data-v-bcfe4bc6 data-v-3a84883f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3a84883f><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3a84883f><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-3a84883f><div class="VPMenu" data-v-3a84883f data-v-010f1d8c><!----><!--[--><!--[--><!----><div class="group" data-v-bcfe4bc6><div class="item appearance" data-v-bcfe4bc6><p class="label" data-v-bcfe4bc6>Appearance</p><div class="appearance-action" data-v-bcfe4bc6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-bcfe4bc6 data-v-57172cb8 data-v-eeb71742><span class="check" data-v-eeb71742><span class="icon" data-v-eeb71742><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-57172cb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-57172cb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-bcfe4bc6><div class="item social-links" data-v-bcfe4bc6><div class="VPSocialLinks social-links-list" data-v-bcfe4bc6 data-v-06a41780><!--[--><a class="VPSocialLink" href="https://github.com/FairyTailYouth" title="github" target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-398c9053><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-398c9053>github</span></a><a class="VPSocialLink" href="..." title="twitter" target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-398c9053><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"></path></svg><span class="visually-hidden" data-v-398c9053>twitter</span></a><a class="VPSocialLink" href="..." target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><!----><span class="visually-hidden" data-v-398c9053>{
  &quot;svg&quot;: &quot;&lt;svg role=\&quot;img\&quot; viewBox=\&quot;0 0 24 24\&quot; xmlns=\&quot;http://www.w3.org/2000/svg\&quot;&gt;&lt;title&gt;Dribbble&lt;/title&gt;&lt;path d=\&quot;M12...6.38z\&quot;/&gt;&lt;/svg&gt;&quot;
}</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-23964494 data-v-702843d0><span class="container" data-v-702843d0><span class="top" data-v-702843d0></span><span class="middle" data-v-702843d0></span><span class="bottom" data-v-702843d0></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-66204374 data-v-a9a4d510><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a9a4d510><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-a9a4d510><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-a9a4d510>Menu</span></button><a class="top-link" href="#" data-v-a9a4d510> Return to top </a></div><aside class="VPSidebar" data-v-66204374 data-v-575b3a38><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-575b3a38><span class="visually-hidden" id="sidebar-aria-label" data-v-575b3a38> Sidebar Navigation </span><!--[--><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>HTML</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>CSS</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>JavaScrpit</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/javascript/index.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>学习连接</span><!--]--><!----></a><a class="VPLink link" href="/articles/javascript/Object%E5%AF%B9%E8%B1%A1.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>Obeject</span><!--]--><!----></a><a class="VPLink link active" href="/articles/javascript/promise%E8%A7%A3%E8%AF%BB.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>promise</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>pinia</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>Vue2</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>Vue3</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>TypeScript</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>Linux</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>组件库源码实现</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/%E7%BB%84%E4%BB%B6%E5%BA%93%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>组件库环境搭建</span><!--]--><!----></a><a class="VPLink link" href="/articles/gulp%E7%9A%84%E4%BD%BF%E7%94%A8.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>gulp的使用</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>vue教程</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/pina%E5%92%8Cvuex.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>pina和vuex</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>webgl教程</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/webGl%E5%9F%BA%E7%A1%80.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>初识webgl</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible collapsed" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>uniapp</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/articles/uniapp/%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>安装配置</span><!--]--><!----></a><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-66204374 data-v-0e4d175a><div class="VPDoc has-sidebar" data-v-0e4d175a data-v-542b5b3a><div class="container" data-v-542b5b3a><div class="aside" data-v-542b5b3a><div class="aside-curtain" data-v-542b5b3a></div><div class="aside-container" data-v-542b5b3a><div class="aside-content" data-v-542b5b3a><div class="VPDocAside" data-v-542b5b3a data-v-719cedd0><!--[--><!--]--><!--[--><!--]--><!----><!--[--><!--]--><div class="spacer" data-v-719cedd0></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-542b5b3a><div class="content-container" data-v-542b5b3a><!--[--><!--]--><main class="main" data-v-542b5b3a><div style="position:relative;" class="vp-doc _articles_javascript_promise%E8%A7%A3%E8%AF%BB" data-v-542b5b3a><div><h1 id="promise" tabindex="-1">promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h1><h5 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-hidden="true">#</a></h5><p><a href="https://wangdoc.com/es6/promise.html" target="_blank" rel="noopener noreferrer">阮一峰的Promise对象</a></p><h4 id="promise-的含义" tabindex="-1">Promise 的含义 <a class="header-anchor" href="#promise-的含义" aria-hidden="true">#</a></h4><p>Promise 是异步编程的一种解决方案,比传统的解决方案——回调函数和事件——更合理和更强大。 简单来说promise就是一个容器里面有各种异步操作的结果 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><h4 id="promise-的状态" tabindex="-1">Promise 的状态 <a class="header-anchor" href="#promise-的状态" aria-hidden="true">#</a></h4><p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><h4 id="promise的缺点" tabindex="-1">Promise的缺点 <a class="header-anchor" href="#promise的缺点" aria-hidden="true">#</a></h4><p>首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p><h4 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-hidden="true">#</a></h4><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const promise = new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 自己写的代码块</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">  if (/* 异步操作成功 */){</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(value);</span></span>
<span class="line"><span style="color:#A6ACCD;">  } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">    reject(error);</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br> resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去<br> Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">promise.then(function(value) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  //成功的回调</span></span>
<span class="line"><span style="color:#A6ACCD;">}, function(error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 失败的回调</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数。</p><p>Promise 新建后就会立即执行。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">let promise = new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;Promise&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">  resolve();</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">promise.then(function() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;resolved.&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(&#39;Hi!&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">//结果</span></span>
<span class="line"><span style="color:#A6ACCD;">// Promise</span></span>
<span class="line"><span style="color:#A6ACCD;">// Hi!</span></span>
<span class="line"><span style="color:#A6ACCD;">// resolved</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="常用api" tabindex="-1">常用Api <a class="header-anchor" href="#常用api" aria-hidden="true">#</a></h4><h5 id="promise-prototype-then" tabindex="-1">Promise.prototype.then() <a class="header-anchor" href="#promise-prototype-then" aria-hidden="true">#</a></h5><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br> 示例代码:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">getJSON(&quot;/posts.json&quot;).then(function(json) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return json.post;</span></span>
<span class="line"><span style="color:#A6ACCD;">}).then(function(post) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // ...</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数<br> 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用</p><p>示例代码:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">getJSON(&quot;/post/1.json&quot;).then(function(post) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return getJSON(post.commentURL);</span></span>
<span class="line"><span style="color:#A6ACCD;">}).then(function (comments) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&quot;resolved: &quot;, comments);</span></span>
<span class="line"><span style="color:#A6ACCD;">}, function (err){</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&quot;rejected: &quot;, err);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">//箭头函数写法</span></span>
<span class="line"><span style="color:#A6ACCD;">getJSON(&quot;/post/1.json&quot;).then(</span></span>
<span class="line"><span style="color:#A6ACCD;">  post =&gt; getJSON(post.commentURL)</span></span>
<span class="line"><span style="color:#A6ACCD;">).then(</span></span>
<span class="line"><span style="color:#A6ACCD;">  comments =&gt; console.log(&quot;resolved: &quot;, comments),</span></span>
<span class="line"><span style="color:#A6ACCD;">  err =&gt; console.log(&quot;rejected: &quot;, err)</span></span>
<span class="line"><span style="color:#A6ACCD;">);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。</p><h5 id="promise-prototype-catch" tabindex="-1">Promise.prototype.catch() <a class="header-anchor" href="#promise-prototype-catch" aria-hidden="true">#</a></h5><p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">getJSON(&#39;/posts.json&#39;).then(function(posts) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // ...</span></span>
<span class="line"><span style="color:#A6ACCD;">}).catch(function(error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;发生错误！&#39;, error);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))</span></span>
<span class="line"><span style="color:#A6ACCD;">  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 等同于</span></span>
<span class="line"><span style="color:#A6ACCD;">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>示例:<br> promise抛出一个错误，就被catch()方法指定的回调函数捕获。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">//写法一</span></span>
<span class="line"><span style="color:#A6ACCD;">const promise = new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  throw new Error(&#39;test&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.catch(function(error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(error);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">//结果</span></span>
<span class="line"><span style="color:#A6ACCD;">// Error: test</span></span>
<span class="line"><span style="color:#A6ACCD;">// 写法二</span></span>
<span class="line"><span style="color:#A6ACCD;">const promise = new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  try {</span></span>
<span class="line"><span style="color:#A6ACCD;">    throw new Error(&#39;test&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">  } catch(e) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    reject(e);</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.catch(function(error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(error);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 写法三</span></span>
<span class="line"><span style="color:#A6ACCD;">const promise = new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  reject(new Error(&#39;test&#39;));</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">promise.catch(function(error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(error);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>如果 Promise 状态已经变成resolved，再抛出错误是无效的。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const promise = new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  resolve(&#39;ok&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">  throw new Error(&#39;test&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">promise</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(function(value) { console.log(value) })</span></span>
<span class="line"><span style="color:#A6ACCD;">  .catch(function(error) { console.log(error) });</span></span>
<span class="line"><span style="color:#A6ACCD;">// ok</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Promise 会吃掉错误 意思就是内部的错误不影响外部代码的执行 promise尽管提示错误但是程序还会一直执行下去,不过在nodejs中专门有处理promise错误的事件，unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误,有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。不过注意的是Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>示例:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const someAsyncThing = function() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 下面一行会报错，因为x没有声明</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(x + 2);</span></span>
<span class="line"><span style="color:#A6ACCD;">  });</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">someAsyncThing().then(function() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;everything is great&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">setTimeout(() =&gt; { console.log(123) }, 2000);</span></span>
<span class="line"><span style="color:#A6ACCD;">//结果</span></span>
<span class="line"><span style="color:#A6ACCD;">// Uncaught (in promise) ReferenceError: x is not defined</span></span>
<span class="line"><span style="color:#A6ACCD;">// 123</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 示例代码：</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const someAsyncThing = function() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return new Promise(function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 下面一行会报错，因为x没有声明</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(x + 2);</span></span>
<span class="line"><span style="color:#A6ACCD;">  });</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">someAsyncThing()</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(function(error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;oh no&#39;, error);</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(function() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;carry on&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">//结果</span></span>
<span class="line"><span style="color:#A6ACCD;">// oh no [ReferenceError: x is not defined]</span></span>
<span class="line"><span style="color:#A6ACCD;">// carry on</span></span>
<span class="line"><span style="color:#A6ACCD;">//解析</span></span>
<span class="line"><span style="color:#A6ACCD;">//上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。果没有报错，则会跳过catch()方法。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="promise-prototype-finally" tabindex="-1">Promise.prototype.finally() <a class="header-anchor" href="#promise-prototype-finally" aria-hidden="true">#</a></h5><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">promise</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(result =&gt; {···})</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(error =&gt; {···})</span></span>
<span class="line"><span style="color:#A6ACCD;">.finally(() =&gt; {···});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p><p>finally本质上是then方法的特例。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">promise</span></span>
<span class="line"><span style="color:#A6ACCD;">.finally(() =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 语句</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 等同于</span></span>
<span class="line"><span style="color:#A6ACCD;">promise</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(</span></span>
<span class="line"><span style="color:#A6ACCD;">  result =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 语句</span></span>
<span class="line"><span style="color:#A6ACCD;">    return result;</span></span>
<span class="line"><span style="color:#A6ACCD;">  },</span></span>
<span class="line"><span style="color:#A6ACCD;">  error =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 语句</span></span>
<span class="line"><span style="color:#A6ACCD;">    throw error;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次 Promise.prototype.finally的js实现代码</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">Promise.prototype.finally = function (callback) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  let P = this.constructor;</span></span>
<span class="line"><span style="color:#A6ACCD;">  return this.then(</span></span>
<span class="line"><span style="color:#A6ACCD;">    value  =&gt; P.resolve(callback()).then(() =&gt; value),</span></span>
<span class="line"><span style="color:#A6ACCD;">    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })</span></span>
<span class="line"><span style="color:#A6ACCD;">  );</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>finally方法总是会返回原来的值。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">// resolve 的值是 undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.resolve(2).then(() =&gt; {}, () =&gt; {})</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// resolve 的值是 2</span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.resolve(2).finally(() =&gt; {})</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// reject 的值是 undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.reject(3).then(() =&gt; {}, () =&gt; {})</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// reject 的值是 3</span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.reject(3).finally(() =&gt; {})</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="promise-all" tabindex="-1">Promise.all() <a class="header-anchor" href="#promise-all" aria-hidden="true">#</a></h5><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p = Promise.all([p1, p2, p3]);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p>p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 示例:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const databasePromise = connectDatabase();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const booksPromise = databasePromise</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(findAllBooks);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const userPromise = databasePromise</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(getCurrentUser);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.all([</span></span>
<span class="line"><span style="color:#A6ACCD;">  booksPromise,</span></span>
<span class="line"><span style="color:#A6ACCD;">  userPromise</span></span>
<span class="line"><span style="color:#A6ACCD;">])</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(([books, user]) =&gt; pickTopRecommendations(books, user));</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p1 = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  resolve(&#39;hello&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(result =&gt; result)</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(e =&gt; e);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const p2 = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  throw new Error(&#39;报错了&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(result =&gt; result)</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(e =&gt; e);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.all([p1, p2])</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(result =&gt; console.log(result))</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(e =&gt; console.log(e));</span></span>
<span class="line"><span style="color:#A6ACCD;">// [&quot;hello&quot;, Error: 报错了]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p><h5 id="promise-race" tabindex="-1">Promise.race() <a class="header-anchor" href="#promise-race" aria-hidden="true">#</a></h5><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p = Promise.race([p1, p2, p3]);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 意思就是竞速，看哪个跑得快 跑得快的作为p的回调函数 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理 示例: 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p = Promise.race([</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/resource-that-may-take-a-while&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  new Promise(function (resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)</span></span>
<span class="line"><span style="color:#A6ACCD;">  })</span></span>
<span class="line"><span style="color:#A6ACCD;">]);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(console.log)</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(console.error);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p><h5 id="promise-allsettled" tabindex="-1">Promise.allSettled() <a class="header-anchor" href="#promise-allsettled" aria-hidden="true">#</a></h5><p>Promise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求 Promise.all()可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束 ES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况 Promise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更 示例:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const promises = [</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/api-1&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/api-2&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/api-3&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">];</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">await Promise.allSettled(promises);</span></span>
<span class="line"><span style="color:#A6ACCD;">removeLoadingIndicator();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面示例中，数组promises包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），removeLoadingIndicator()才会执行。</p><p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const resolved = Promise.resolve(42);</span></span>
<span class="line"><span style="color:#A6ACCD;">const rejected = Promise.reject(-1);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const allSettledPromise = Promise.allSettled([resolved, rejected]);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">allSettledPromise.then(function (results) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(results);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">// [</span></span>
<span class="line"><span style="color:#A6ACCD;">//    { status: &#39;fulfilled&#39;, value: 42 },</span></span>
<span class="line"><span style="color:#A6ACCD;">//    { status: &#39;rejected&#39;, reason: -1 }</span></span>
<span class="line"><span style="color:#A6ACCD;">// ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。它的回调函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入Promise.allSettled()的数组里面的两个 Promise 对象。 results的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">// 异步操作成功时</span></span>
<span class="line"><span style="color:#A6ACCD;">{status: &#39;fulfilled&#39;, value: value}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 异步操作失败时</span></span>
<span class="line"><span style="color:#A6ACCD;">{status: &#39;rejected&#39;, reason: reason}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>成员对象的status属性的值只可能是字符串fulfilled或字符串rejected，用来区分异步操作是成功还是失败。如果是成功（fulfilled），对象会有value属性，如果是失败（rejected），会有reason属性，对应两种状态时前面异步操作的返回值。</p><p>返回值的用法例子:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const promises = [ fetch(&#39;index.html&#39;), fetch(&#39;https://does-not-exist/&#39;) ];</span></span>
<span class="line"><span style="color:#A6ACCD;">const results = await Promise.allSettled(promises);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 过滤出成功的请求</span></span>
<span class="line"><span style="color:#A6ACCD;">const successfulPromises = results.filter(p =&gt; p.status === &#39;fulfilled&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// 过滤出失败的请求，并输出原因</span></span>
<span class="line"><span style="color:#A6ACCD;">const errors = results</span></span>
<span class="line"><span style="color:#A6ACCD;">  .filter(p =&gt; p.status === &#39;rejected&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">  .map(p =&gt; p.reason);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="promise-any" tabindex="-1">Promise.any() <a class="header-anchor" href="#promise-any" aria-hidden="true">#</a></h5><p>ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。 只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">Promise.any([</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;https://v8.dev/&#39;).then(() =&gt; &#39;home&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;https://v8.dev/blog&#39;).then(() =&gt; &#39;blog&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;https://v8.dev/docs&#39;).then(() =&gt; &#39;docs&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">]).then((first) =&gt; {  // 只要有一个 fetch() 请求成功</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(first);</span></span>
<span class="line"><span style="color:#A6ACCD;">}).catch((error) =&gt; { // 所有三个 fetch() 全部请求失败</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(error);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</p><p>下面是Promise()与await命令结合使用的例子。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const promises = [</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),</span></span>
<span class="line"><span style="color:#A6ACCD;">];</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">try {</span></span>
<span class="line"><span style="color:#A6ACCD;">  const first = await Promise.any(promises);</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(first);</span></span>
<span class="line"><span style="color:#A6ACCD;">} catch (error) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(error);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。</p><p>Promise.any()抛出的错误是一个 AggregateError 实例（详见《对象的扩展》一章），这个 AggregateError 实例对象的errors属性是一个数组，包含了所有成员的错误。 示例:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">var resolved = Promise.resolve(42);</span></span>
<span class="line"><span style="color:#A6ACCD;">var rejected = Promise.reject(-1);</span></span>
<span class="line"><span style="color:#A6ACCD;">var alsoRejected = Promise.reject(Infinity);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.any([resolved, rejected, alsoRejected]).then(function (result) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(result); // 42</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.any([rejected, alsoRejected]).catch(function (results) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(results instanceof AggregateError); // true</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(results.errors); // [-1, Infinity]</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="promise-resolve" tabindex="-1">Promise.resolve() <a class="header-anchor" href="#promise-resolve" aria-hidden="true">#</a></h5><p>有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 示例:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve()等价于下面的写法。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">Promise.resolve(&#39;foo&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">// 等价于</span></span>
<span class="line"><span style="color:#A6ACCD;">new Promise(resolve =&gt; resolve(&#39;foo&#39;))</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Promise.resolve()方法的参数分成四种情况。</p><p>（1）参数是一个 Promise 实例</p><p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p><p>（2）参数是一个thenable对象</p><p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">let thenable = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  then: function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(42);</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">let thenable = {</span></span>
<span class="line"><span style="color:#A6ACCD;">  then: function(resolve, reject) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    resolve(42);</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">let p1 = Promise.resolve(thenable);</span></span>
<span class="line"><span style="color:#A6ACCD;">p1.then(function (value) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(value);  // 42</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>（3）参数不是具有then()方法的对象，或根本就不是对象</p><p>如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p = Promise.resolve(&#39;Hello&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p.then(function (s) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(s)</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">// Hello</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。</p><p>（4）不带有任何参数</p><p>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p = Promise.resolve();</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p.then(function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // ...</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">setTimeout(function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;three&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}, 0);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.resolve().then(function () {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&#39;two&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(&#39;one&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// one</span></span>
<span class="line"><span style="color:#A6ACCD;">// two</span></span>
<span class="line"><span style="color:#A6ACCD;">// three</span></span>
<span class="line"><span style="color:#A6ACCD;">//setTimeout(fn, 0)在下一轮“事件循环”开始时执行</span></span>
<span class="line"><span style="color:#A6ACCD;">//Promise.resolve()在本轮“事件循环”结束时执行，</span></span>
<span class="line"><span style="color:#A6ACCD;">//console.log(&#39;one&#39;)则是立即执行1</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h5 id="promise-reject" tabindex="-1">Promise.reject() <a class="header-anchor" href="#promise-reject" aria-hidden="true">#</a></h5><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const p = Promise.reject(&#39;出错了&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">// 等同于</span></span>
<span class="line"><span style="color:#A6ACCD;">const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">p.then(null, function (s) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(s)</span></span>
<span class="line"><span style="color:#A6ACCD;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">// 出错了</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。</p><p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">Promise.reject(&#39;出错了&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(e =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(e === &#39;出错了&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">// true</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h4 id="promise-try" tabindex="-1">Promise.try() <a class="header-anchor" href="#promise-try" aria-hidden="true">#</a></h4><p>让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">const f = () =&gt; console.log(&#39;now&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">Promise.try(f);</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(&#39;next&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;">// now</span></span>
<span class="line"><span style="color:#A6ACCD;">// next</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>示例:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">function getUsername(userId) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return database.users.get({id: userId})</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(function(user) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return user.name;</span></span>
<span class="line"><span style="color:#A6ACCD;">  });</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">database.users.get({id: userId})</span></span>
<span class="line"><span style="color:#A6ACCD;">.then(...)</span></span>
<span class="line"><span style="color:#A6ACCD;">.catch(...)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">try {</span></span>
<span class="line"><span style="color:#A6ACCD;">  database.users.get({id: userId})</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(...)</span></span>
<span class="line"><span style="color:#A6ACCD;">  .catch(...)</span></span>
<span class="line"><span style="color:#A6ACCD;">} catch (e) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // ...</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">Promise.try(() =&gt; database.users.get({id: userId}))</span></span>
<span class="line"><span style="color:#A6ACCD;">  .then(...)</span></span>
<span class="line"><span style="color:#A6ACCD;">  .catch(...)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p></div></div></main><footer class="VPDocFooter" data-v-542b5b3a data-v-25535ebb><div class="edit-info" data-v-25535ebb><!----><!----></div><div class="prev-next" data-v-25535ebb><div class="pager" data-v-25535ebb><a class="pager-link prev" href="/articles/javascript/Object%E5%AF%B9%E8%B1%A1.html" data-v-25535ebb><span class="desc" data-v-25535ebb>Previous page</span><span class="title" data-v-25535ebb>Obeject</span></a></div><div class="has-prev pager" data-v-25535ebb><a class="pager-link next" href="/articles/pina%E5%92%8Cvuex.html" data-v-25535ebb><span class="desc" data-v-25535ebb>Next page</span><span class="title" data-v-25535ebb>pina和vuex</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"articles_gulp的使用.md\":\"3a020bd7\",\"articles_javascript_object对象.md\":\"b0d00f40\",\"articles_javascript_idnex.md\":\"3064af3b\",\"articles_javascript_promise解读.md\":\"64285721\",\"articles_pina和vuex.md\":\"7e312b1f\",\"articles_uniapp_安装和使用.md\":\"ad740138\",\"articles_webgl基础.md\":\"f071465d\",\"articles_组件库环境搭建.md\":\"d0d45d44\",\"guide_index.md\":\"a6975c33\",\"guide_test.md\":\"7b9d0bc2\",\"index.md\":\"e6dc1d44\"}")</script>
    <script type="module" async src="/assets/app.f97f91c0.js"></script>
    
  </body>
</html>